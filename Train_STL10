import torch
import torchvision
import torchvision.transforms as transforms
import numpy as np
import matplotlib.pyplot as plt
from sklearn.tree import DecisionTreeClassifier
from sklearn.svm import SVC
from sklearn.model_selection import train_test_split

# Tải dữ liệu STL-10
stl10 = torchvision.datasets.STL10(
    root='./data',
    download=True,
    transform=transforms.Compose([
        transforms.ToTensor(),
    ])
)

# Chia tập dữ liệu thành tập huấn luyện và tập kiểm tra
train_dataset, test_dataset = torch.utils.data.random_split(stl10, [int(0.8 * len(stl10)), len(stl10) - int(0.8 * len(stl10))])

# Tạo lớp dữ liệu tùy chỉnh
class CustomDataset(torch.utils.data.Dataset):
    def __init__(self, dataset):
        self.dataset = dataset

    def __len__(self):
        return len(self.dataset)

    def __getitem__(self, idx):
        image, label = self.dataset[idx]

        # Lật ảnh ngẫu nhiên
        flip = np.random.rand()
        if flip > 0.5:
            image = image.flip(2)  # Lật ảnh theo trục ngang
            flip_label = 1
        else:
            flip_label = 0

        return image, flip_label

# Tạo tập dữ liệu mới
train_dataset = CustomDataset(train_dataset)
test_dataset = CustomDataset(test_dataset)

# Chuyển đổi dữ liệu từ Tensor đến numpy array
train_images = np.array([img.numpy() for img, _ in train_dataset])
train_labels = np.array([label for _, label in train_dataset])

test_images = np.array([img.numpy() for img, _ in test_dataset])
test_labels = np.array([label for _, label in test_dataset])

# Huấn luyện mô hình DecisionTree
train_images_flattened = train_images.reshape(-1, 3 * 96 * 96)
train_labels_flattened = train_labels.reshape(-1, 1)

decision_tree_model = DecisionTreeClassifier()
decision_tree_model.fit(train_images_flattened, train_labels_flattened.ravel())

# Huấn luyện mô hình SVM
svm_model = SVC()
svm_model.fit(train_images_flattened, train_labels_flattened.ravel())

# Đánh giá mô hình
test_images_flattened = test_images.reshape(-1, 3 * 96 * 96)
test_labels_flattened = test_labels.reshape(-1, 1)

decision_tree_predictions = decision_tree_model.predict(test_images_flattened)
svm_predictions = svm_model.predict(test_images_flattened)

decision_tree_accuracy = np.mean(decision_tree_predictions == test_labels_flattened.ravel())
svm_accuracy = np.mean(svm_predictions == test_labels_flattened.ravel())

print("DecisionTree accuracy: {:.2f}%".format(decision_tree_accuracy * 100))
print("SVM accuracy: {:.2f}%".format(svm_accuracy * 100))

# In ra hình dự đoán sai của 3 lớp có số dự đoán sai nhiều nhất
# Tôi sẽ giới hạn đoạn code này với 3 lớp đầu tiên
decision_tree_incorrect_indices = np.where(decision_tree_predictions != test_labels_flattened.ravel())[0]
svm_incorrect_indices = np.where(svm_predictions != test_labels_flattened.ravel())[0]

decision_tree_incorrect_indices = decision_tree_incorrect_indices[:30]
svm_incorrect_indices = svm_incorrect_indices[:30]

decision_tree_incorrect_images = test_images[decision_tree_incorrect_indices]
svm_incorrect_images = test_images[svm_incorrect_indices]

decision_tree_incorrect_labels = test_labels[decision_tree_incorrect_indices]
svm_incorrect_labels = test_labels[svm_incorrect_indices]

fig, axs = plt.subplots(2, 15)

for i in range(15):
    axs[0, i].imshow(decision_tree_incorrect_images[i].transpose(1, 2, 0))
    axs[0, i].axis('off')
    axs[0, i].set_title("DecisionTree: Predicted {}".format(decision_tree_incorrect_labels[i]))

    axs[1, i].imshow(svm_incorrect_images[i].transpose(1, 2, 0))
    axs[1, i].axis('off')
    axs[1, i].set_title("SVM: Predicted {}".format(svm_incorrect_labels[i]))

plt.show()
